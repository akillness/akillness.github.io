---
title: ü§© ùêÄùê∞ùêûùê¨ùê®ùê¶ùêû-ùêèùê´ùê®ùêùùêÆùêúùê≠ùê¢ùê®ùêß-ùêãùêãùêå
description: LLM, Application
categories: [LLM, Application]
tags: [LLM, Application]
# author: foDev_jeong
date: 2024-08-03 13:00:00 +0800
# pin: true
# math: true
# mermaid: true
# image:
#   path: /assets/img/cover/programming.jpeg
#   lqip: data:image/webp;base64,UklGRpoAAABXRUJQVlA4WAoAAAAQAAAADwAABwAAQUxQSDIAAAARL0AmbZurmr57yyIiqE8oiG0bejIYEQTgqiDA9vqnsUSI6H+oAERp2HZ65qP/VIAWAFZQOCBCAAAA8AEAnQEqEAAIAAVAfCWkAALp8sF8rgRgAP7o9FDvMCkMde9PK7euH5M1m6VWoDXf2FkP3BqV0ZYbO6NA/VFIAAAA
#   alt: [2024 programming curriculum by honglab]
---


# This repository contains a curated list of awesome open-source libraries for production large language models. 

59 projects are selected with high standards.

- üìöLLM Data Preprocessing (6)
- ü§ñLLM Training / Finetuning (12)
- üìäLLM Evaluation / Benchmark (6)
- üöÄLLM Serving / Inference (12)
- üõ†Ô∏èLLM Application / RAG (12)
- üßêLLM Testing / Monitoring (7)
- üõ°Ô∏èLLM Guardrails / Security (4)

> Github üëâ <https://github.com/jihoo-kim/awesome-production-llm>
{: .prompt-info}

![ Flow to build application with llms ](/assets/img/llm/build-applications-with-llms.gif){: .light .shadow .rounded-10 w='1212' h='668' }

What's your take on this framework? 

Any additional architectural considerations you'd add for enterprise-grade LLM applications? 

P.S. Curious about the latest in LLM efficiency? Check out the recent papers on model distillation and quantization.


<details markdown="1">
<summary style= "font-size:24px; line-height:24px; font-weight:bold; cursor:pointer;" > A 7-Step Technical Framework </summary>

# Architecting Robust LLM-Powered Applications

Let's dive deep into the architecture of Language Model (LLM) powered applications. 

Here's a comprehensive framework to guide your next cutting-edge project:

üå¥üî¨ ùóïùóºùóªùòÇùòÄ: Join me for an advanced workshop on LLM application architecture. 

## We'll cover topics like building Robust Real-Time AI Apps on Iceberg Data

### 1Ô∏è‚É£ Define Application Scope and User Interaction Model
 - Identify core use cases and potential edge cases
 - Design the user interaction flow (e.g., multi-turn dialogues, single-query responses)
 - Consider scalability and performance requirements

### 2Ô∏è‚É£ Engineer Prompt Chain Architecture
 - Implement prompt engineering techniques (e.g., few-shot learning, chain-of-thought)
 - Develop a robust prompt template system with version control
 - Optimize for token efficiency and response coherence

### 3Ô∏è‚É£ Implement Stateful Conversations with Advanced Memory Buffers
 - Choose appropriate memory structures (e.g., sliding window, summary buffers)
 - Implement efficient serialization and deserialization of conversation state
 - Design memory management strategies for long-running sessions

### 4Ô∏è‚É£ Integrate Retrieval-Augmented Generation (RAG) and Tool Use
 - Implement vector databases for semantic search capabilities
 - Develop a flexible tool-use framework (consider the OpenAI function calling paradigm)
 - Design fall-back mechanisms for API failures or out-of-domain queries

### 5Ô∏è‚É£ Establish Robust Data Processing Pipeline
 - Implement ETL processes for diverse data sources
 - Develop efficient indexing strategies for quick retrieval
 - Design data validation and sanitization protocols

### 6Ô∏è‚É£ Rigorous Testing and Iterative Refinement
 - Implement comprehensive unit and integration testing suites
 - Develop metrics for response quality, latency, and coherence
 - Utilize A/B testing for prompt and model optimization

### 7Ô∏è‚É£ Production Deployment and Monitoring
 - Containerize your application for consistent deployment
 - Implement robust logging and telemetry
 - Design auto-scaling mechanisms to handle variable load

</details>




